* About
** Happy
   - Happy is a parser generator for haskell. like yacc/bison is for C.
   - its lexer equivalent is called Alex, which i just implemented use of
   - install happy and alex using:
     #+BEGIN_EXAMPLE
     cabal update
     cabal install happy
     cabal install alex
     #+END_EXAMPLE
     it may sit there for a while, but it's doing stuff
** Requirements
   - This program requires cabal, alex and happy, and ghc obviously
   - ghc and cabal can be install using pacman on arch, probably apt-get on ubuntu or whatever ari uses
   - otherwise cabal will take care of libraries when you run the command:
     #+BEGIN_EXAMPLE
     cabal install --dependencies-only
     #+END_EXAMPLE
** Building
   - Although this is build using cabal to manage dependencies and whatnot, telling cabal to build it didn't seem to re-run happy, so I just have the makefile run happy and then call cabal.
   - to compile if you have modified ~Parser.y~ or ~Lexer.x~, just run:
     #+BEGIN_EXAMPLE
     make
     #+END_EXAMPLE
   - If you have just modified ~Main.hs~ or another file that doesn't exist yet, you can just run
     #+BEGIN_EXAMPLE
     cabal build
     #+END_EXAMPLE
*** Remember
    To install libraries manually, run
    #+BEGIN_EXAMPLE
    cabal install package
    #+END_EXAMPLE
** Running
   - to be able to use the PATH variable properly, the program must be invoked with a modified PATH variable (for some reason, unknown), e.g. ~env -i ./dist/build/Haskshell/Haskshell~ or ~PATH=$PATH ./dist/build/Haskshell/Haskshell~. Why? - no idea, have not looked into it yet.
* TODOs
  - [X] switch from system.posix.process to system.process, for return val and pipe support
    + hopefully this will fix the order of execution of commands not being guaranteeable, i.e. not forked
  - [ ] problem -- varRef vs single word commands. possible solution:
    - make if-stmts only contain exprs if theyre wrapped in brackets of some sort
  - [ ] make ComArgs take Literals instead of raw strings ?
  - [ ] think about ambiguity, e.g. 'if 1 == 2 then echo hi ; a = 2' gets parsed as 'if .. then ( echo hi ; a = 2)'
    - edit %left precedence accordingly
  - [X] find a better way to handle empty lines
  - [X] start using alex. adding '==' support broke assignment without spaces
  - [ ] seperate Expression datatype into Expression and Literal?
  - [ ] make variable evaluation explicit
  - [ ] other things that are listed throughout the code
