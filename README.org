* About
** Happy
   - Happy is a parser generator for haskell. like yacc/bison is for C.
   - its lexer equivalent is called Alex, but I haven't implemented the use of it, and idk if we'll need it. We'll see
   - install happy using:
     #+BEGIN_EXAMPLE
     cabal update
     cabal install happy
     #+END_EXAMPLE
     it may sit there for a while, but it's doing stuff
** Requirements
   - This program requires cabal and happy, and ghc obviously
   - ghc and cabal can be install using pacman on arch, probably apt-get on ubuntu or whatever ari uses
   - otherwise cabal will take care of libraries when you run the command:
     #+BEGIN_EXAMPLE
     cabal install --dependencies-only
     #+END_EXAMPLE
** Building
   - Although this is build using cabal to manage dependencies and whatnot, telling cabal to build it didn't seem to re-run happy, so I just have the makefile run happy and then call cabal.
   - to compile, just run:
     #+BEGIN_EXAMPLE
     make
     #+END_EXAMPLE
*** Remember
    To install libraries manually, run
    #+BEGIN_EXAMPLE
    cabal install package
    #+END_EXAMPLE
* TODOs
  - [ ] switch from system.posix.process to system.process, for return val and pipe support
    + hopefully this will fix the order of execution of commands not being guaranteeable, i.e. not forked
  - [ ] problem -- varRef vs single word commands. possible solution:
    - make if-stmts only contain exprs if theyre wrapped in brackets of some sort
  - [ ] make ComArgs take Literals instead of raw strings
  - [ ] think about ambiguity, e.g. 'if 1 == 2 then echo hi ; a = 2' gets parsed as 'if .. then ( echo hi ; a = 2)'
    - edit %left precedence accordingly
  - [ ] find a better way to handle empty lines
  - [ ] start using alex. adding '==' support broke assignment without spaces
